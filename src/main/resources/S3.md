### Question 1
**Explain in your own words, with examples, the different between static and non-static methods and
fields.**

Static fields are attributes which are associated with the class itself, whereas non-static fields are attributes associated with instances of a class.

Similarly, static methods are behaviours which belong to the class itself, and non static methods can only be called with an instance of a class.


### Question 2

**Explain why the following code excerpts behave differently when compiled and run:**
```java 
   String s1 = new String("Hi");
   String s2 = new String("Hi");
   System.out.println( (s1==s2) );
   String s3 = "Hi";
   String s4 = "Hi";
   System.out.println( (s3==s4) );
   ```
   

A string literal is a sequence of characters enclosed in double quotation marks such as ``` "Hello World"```
When a string literal is created, Java checks the string pool. If the string literal appears already in the string pool, the new string will reference to the same object in the string pool.
However, using the ```new``` keyword explicitly assigns new chunk of memory in the heap to the object, regardless of whether the content is the same as an existing string in the pool.

The ```.equals``` method in Java checks if two references point to the same object.
Therefore, in case 1, they will not; and in Case 2, they will.

### Question 3

```java 
    public class Car {
        private String manufacturer;
        private int age;

        public int getAge() {
            return age;
        }

        public String getManufacturer() {
            return manufacturer;
        }

        public Car(String manufacturer, int age) {
            this.age = age;
            this.manufacturer = manufacturer;
        }

    }

    class carComparator implements Comparator<Car> {
        @Override
        public int compare(Car c1, Car c2) {
            int a = c1.getManufacturer().compareTo(c2.getManufacturer());
            if (a == 0) {
                if (c1.getAge() > c2.getAge())
                    return 1;
                else if (c1.getAge() == c2.getAge()) {
                    return 0;
                }
                else
                    return -1;
            }
            return a;
        }


        public static void main(String[] args) {

            List<Car> carcollection = new ArrayList<>();
            carcollection.add(new Car("abc", 1));
            carcollection.add(new Car("bc", 1));
            carcollection.add(new Car("abc", 2));
            Collections.sort(carcollection, new carComparator());
            for (Car i : carcollection) {
                System.out.println("Age: "+ i.getAge() + " Manafacturer:" + i.getManufacturer());
            }
        }
    }
    
```
### Question 4

The strategy pattern is where a family of algorithms are defined, but achieves the same result through different ways. It allows the client to choose a type
of algorithm from the family of algorithms during run time.
1. **Context:**
The context is a class which contains a reference to the strategy interface.
The context does not know which strategy is executed, and what it's specific algorithm is.
Includes a setter for the client to set the strategy at runtime.
2. **Strategy Interface:**
An interface which defines abstract methods which are implemented by all concrete strategies.
3. **Concrete Strategy:** Concrete classes which implement the strategy interface.
Each concrete strategy provides a different implementation of the algorithm encapsulated by the strategy interface.
4. **Client:**
Creates a specific concrete strategy object and passes it to the context.

The state pattern is where different types of algorithms are performed based
on the current state of the machine. Different transitions can be followed from each state to 
end up at a different state.
1. **Context:**
The context is a class which stores a reference to its state.
Communicates with state object only via state interface/abstract class.
2. **State interface/abstract class:**
Defines abstract methods that all concrete states have to implement.
3. **Concrete States:**
These classes implement methods from the state interface/abstract class.
Can perform transitions to the next state.

**Comparison:**

State is a subset of Strategy. Both patterns are based on composition, changing behaviour of
the context through delegating work to helper objects.

However, strategies are completely independent and unaware of each other whereas states
can be dependent as you can jump from one state to another.

Strategy pattern is about having different implementations that accomplish the same thing, whereas State pattern 
is about doing different 
things based on the state (reducing the use of if-else statements).

### Question 5
```java
public class Singleton {
    static Singleton s = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() {
        return s;
    }

    public static void main(String[] args) {
        Singleton.getInstance();
    }
}
```

Singleton design pattern is where only one instance of the object can exist and
a global point of access is provided to that instance.

Advantages & Disadvantages

### Question 6