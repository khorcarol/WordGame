### Question 1
**Explain in your own words, with examples, the different between static and non-static methods and
fields.**

Static fields are attributes which are associated with the class itself, whereas non-static fields are attributes associated with instances of a class.

Similarly, static methods are behaviours which belong to the class itself, and non static methods can only be called with an instance of a class.


### Question 2

**Explain why the following code excerpts behave differently when compiled and run:**
```java 
   String s1 = new String("Hi");
   String s2 = new String("Hi");
   System.out.println( (s1==s2) );
   String s3 = "Hi";
   String s4 = "Hi";
   System.out.println( (s3==s4) );
   ```
   

A string literal is a sequence of characters enclosed in double quotation marks such as ``` "Hello World"```
When a string literal is created, Java checks the string pool. If the string literal appears already in the string pool, the new string will reference to the same object in the string pool.
However, using the ```new``` keyword explicitly assigns new chunk of memory in the heap to the object, regardless of whether the content is the same as an existing string in the pool.

The ```.equals``` method in Java checks if two references point to the same object.
Therefore, in case 1, they will not; and in Case 2, they will.

### Question 3

**The user of the class Car below wishes to maintain a collection of Car objects such that they can be
iterated over in some specific order. Using a Comparator, show how to keep the collection sorted by manufacturer, age. i.e. sort
first by manufacturer, and sub-sort by age.**

```java 
    public class Car {
        private String manufacturer;
        private int age;

        public int getAge() {
            return age;
        }

        public String getManufacturer() {
            return manufacturer;
        }

        public Car(String manufacturer, int age) {
            this.age = age;
            this.manufacturer = manufacturer;
        }

    }

    class carComparator implements Comparator<Car> {
        @Override
        public int compare(Car c1, Car c2) {
            int a = c1.getManufacturer().compareTo(c2.getManufacturer());
            if (a == 0) {
                if (c1.getAge() > c2.getAge())
                    return 1;
                else if (c1.getAge() == c2.getAge()) {
                    return 0;
                }
                else
                    return -1;
            }
            return a;
        }


        public static void main(String[] args) {

            List<Car> carcollection = new ArrayList<>();
            carcollection.add(new Car("abc", 1));
            carcollection.add(new Car("bc", 1));
            carcollection.add(new Car("abc", 2));
            Collections.sort(carcollection, new carComparator());
            for (Car i : carcollection) {
                System.out.println("Age: "+ i.getAge() + " Manafacturer:" + i.getManufacturer());
            }
        }
    }
    
```
### Question 4
**Explain the difference between the State pattern and the Strategy pattern.**
The strategy pattern is where a family of algorithms are defined, but achieves the same result through different ways. It allows the client to choose a type
of algorithm from the family of algorithms during run time.
1. **Context:**
The context is a class which contains a reference to the strategy interface.
The context does not know which strategy is executed, and what it's specific algorithm is.
Includes a setter for the client to set the strategy at runtime.
2. **Strategy Interface:**
An interface which defines abstract methods which are implemented by all concrete strategies.
3. **Concrete Strategy:** Concrete classes which implement the strategy interface.
Each concrete strategy provides a different implementation of the algorithm encapsulated by the strategy interface.
4. **Client:**
Creates a specific concrete strategy object and passes it to the context.

```java
public class Context {
    private StrategyInterface strategyInterface;

    public void setStrategyInterface(StrategyInterface strategyInterface) {
        this.strategyInterface = strategyInterface;
    }

    public StrategyInterface getStrategyInterface() {
        return strategyInterface;
    }
}

public interface StrategyInterface {
    void Do();
}

public class ConcreteStrategy implements StrategyInterface{
    public void Do(){
        System.out.println("Doing Concrete Strategy");}
}

public class Main {
    public static void main(String[] args) {
        Context c = new Context();
        c.setStrategyInterface(new ConcreteStrategy());
        c.getStrategyInterface().Do();
    }
}


```

The state pattern is where different types of algorithms are performed based
on the current state of the machine. Different transitions can be followed from each state to 
end up at a different state.
1. **Context:**
The context is a class which stores a reference to its state.
Communicates with state object only via state interface/abstract class.
2. **State interface/abstract class:**
Defines abstract methods that all concrete states have to implement.
3. **Concrete States:**
These classes implement methods from the state interface/abstract class.
Can perform transitions to the next state.

```java
public class Context {
    private StateInterface stateInterface;

    public void setStateInterface(StateInterface stateInterface) {
        this.stateInterface = stateInterface;
    }

    public void Do(){
        stateInterface.Do(this);
    }

    public static void main(String[] args) {
        Context context = new Context();
        context.setStateInterface(new StateOne());
        context.Do();
        context.Do();
    }
}


public interface StateInterface {
    void Do(Context context);
}

public class StateOne implements StateInterface {
    public void Do(Context context) {
        System.out.println("Doing State One");
        context.setStateInterface(new StateTwo());

    }
}

public class StateTwo implements StateInterface {
    public void Do(Context context) {
        System.out.println("Doing State Two");
        context.setStateInterface(new StateOne());

    }
}
```

**Comparison:**

State is a subset of Strategy. Both patterns are based on composition, changing behaviour of
the context through delegating work to helper objects.

However, strategies are completely independent and unaware of each other whereas states
can be dependent as you can jump from one state to another.

Strategy pattern is about having different implementations that accomplish the same thing, whereas State pattern 
is about doing different 
things based on the state (reducing the use of if-else statements).

### Question 5
**Describe the Singleton Pattern (with an example in code) and explain the advantages and
disadvantages of using it.**
```java
public class Singleton {
    static Singleton s = new Singleton();
    private Singleton() {} //private constructor
    public static Singleton getInstance() {
        return s;
    }

    public static void main(String[] args) {
        Singleton.getInstance();
    }
}
```

Singleton design pattern is where only one instance of the object can exist and
a global point of access is provided to that instance. It helps avoid item duplication, 
which means reduces memory usage. Examples of when it may be useful include when establishing 
a database connection, where only one instance should exist.

Because a Singleton object is accessed globally, making modifications to it will result in 
changes in the entire application.  

### Question 6
**Research a design pattern that has not been covered in the course. Describe and explain it with
examples to illustrate your understanding. You will need to present this during the supervision.**

The Decorator Pattern is a structural design pattern which allows one to attach
new behaviours to an object by placing this object inside a special wrapper that 
contains these behaviours.

**Component interface:**
Declares common behaviours for both wrappers and wrapped objects

**Concrete Component:**
Wrapped class which defines basic behaviours, which are altered by decorators.

**Base Decorator:**
Has a field which references the wrapped object via the interface.

**Concrete Decorator:**
Overrides methods of the base decorator.

```java
interface Component {
    void doSomething();
}
public class ConcreteComponent implements Component {
    @Override
    public void doSomething() {
        System.out.println("Concrete Component does something.");
    }
}
public class BaseDecorator implements Component{
    Component wrapped;

    @Override
    public void doSomething() {
        wrapped.doSomething();
    }
}

public class DecoratorOne extends BaseDecorator{

    public DecoratorOne(Component wrapped){
        super.wrapped = wrapped;
    }
    @Override
    public void doSomething(){
        super.doSomething();
        System.out.println("DecoratorOne does something");
    }
}
public class Main {
    public static void main(String[] args) {
        Component c = new DecoratorOne(new ConcreteComponent());
        c.doSomething();
    }
}

```

### Question 7
**Research and describe two anti-patterns that affect OOP and explain the disadvantages. You will need
to present one during the supervision.**

Inappropriate inheritance. Inheritance should be used in true "is-a" relationships.
Subclasses should be substitutable for the base types without negative side effects by Liskov Substitution Principle.

Anemic Domain Model is where the domain model (representations of real world entities) contain primarily data, with 
little to none business logic. So the data and the operations are separate.

### Question 8
**Design, using UML, a Cyber Pet game. Your design should allow for a text UI initially but with a view
that you can swap it out for a full GUI in the future. Your game should allow for a variety of Cyber Pets
(Dogs, Fish, Ninja’s etc.) to be created and for actions to be invoked on them. E.g. feed, play, sleep. The
pet should get tired and hungry when you play with it and feeding and sleeping should affect the pet.
You might like to consider what happens if your Cyber Pet gets fed too much or not at all. Feel free to
be creative and add additional features.**

<img src="C:\Users\shunt\Cambridge\Java\S3\Supo3\src\main\resources\CyberPet.png"/>

### Question 9
a)
Encapsulation is done through making the PushbackReader
field private, as seen in Line 2. This means no methods outside of class Swapper can access this field.

Abstraction can be done through composition, where methods of the class Swapper contains
instances of PushbackReader to reuse it functionality, hiding the unnecessary details
and only exposing essential features of the object, as seen in Line 3.

Inheritance of code is done through the class Swapper extending Reader, as seen in Line 1. Swapper will inherit methods 
and behaviours of Reader.

Dynamic Polymorphism 
In line 6, class Swapper overrides the read method of the original Reader
class. During runtime, it will be decided if the object is a Swapper or a Reader.
If it is a Swapper (child of Reader), the read method of the Swapper will be used. This is dynamic
polymorphism as the compiler does not know the type of the object during compile time.

b)

In this case, PushbackReader is the Component interface.
Swapper is the Decorator. Reader is the Base Decorator.

In the Swapper constructor, it should call super(PushbackReader) so 
that the Reader(BaseDecorator) field wrap is set. 
Then when invoking read in Swapper(Decorator), we call the super method of read, which will call the wrapped(another type 
of decorator's) read method.
This will recursively continue until we hit the Concrete Component, which will presumably return an integer. 
The call stack now will decrease as each decorator function is continued.

```java
class Swapper extends Reader {
    private final PushbackReader pushBack;
    Swapper(PushbackReader p) {super.wrap = p;}

    @Override
    public int read(char[] cbuf, int off, int len) {
        int r = super.read(cbuf, off, len);
        if (r % 2 == 1) { pushBack.unread(cbuf, off + --r, 1); }
        for (int i = 0; i < r; i += 2) { swap(cbuf, i, i + 1); }
        return r;
    }
}
class Reader{
    PushbackReader wrap;
    public int read(char[] cbuf, int off, int len){
        wrap.read(char[] cbuf, int off, int len);        
    }
}
```


c) Open to extension, closed to modification.
We can add new Decorators, classes which extend Reader without 
modifying existing code in Reader or PushbackReader.

d)

```java
import java.io.PushbackReader;

public class Swapper() {
    private IStrategy ist;

    public void setIst(IStrategy ist) {
        this.ist = ist;
    }
    Swapper(PushbackReader p, IStrategy ist )
    {pushback = p; this.ist = ist;}
    ...
            for(int i = 0;i<r;i +=2){
        ist.sort(cbuf, i, i + 1);
    }
    ...

}

public interface Strategy() {
    void sort(char[] cbuf, int off, int len);
}

public class Swap() {
    public void sort(char[] cbuf, int off, int len) {
        swap(cbuf, i, i + 1);
    }
}

public class AnotherOperation() {
    public void sort(char[] cbuf, int off, int len) {
        anotherOperation(cbuf, i, i + 1);
    }
}

```

e) Swapper can only extend either Reader (used to read characters)
or Stream (used to read binary data). 
If the Swapper class shares a composition relationship, that is
it contains instances of Reader and Stream, then it can read both 
bytes and characters,

However, this means the Decryptor class would also require to be changed
to include ways to handle both cases. In that case, to not violate OCP,
we would introduce different types of Decryptors (for images and character) which both implement the Decryptor
class.

This shows how OOP design should follow the Single Responsibility Pattern.
If too many responsibilities reside within a class, then the code would need
to be regularly changed.

### Question 10

```java
package stk31.WordGame.word_game;

import java.awt.*;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;

import javax.swing.*;

import stk31.WordGame.word_game.grid.*;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

/**
 * Game This is a basic class that can be modified to create a word game.
 * <p>
 * Hint: Can this class be converted into a singleton?
 *
 * @author Stephen Cummins
 * @version 1.0 Released 11/10/2005
 */
public class Game extends JPanel {
    private static final long serialVersionUID = 1L;
    private static Game game;
    private static String currentword = "";
    private final String filePath = "C:\\Users\\shunt\\Cambridge\\Java\\S3\\Supo3\\src\\main\\java\\stk31\\WordGame\\OOPIncompleteWordGame\\src\\main\\resources\\words.txt";
    private final ArrayList<Tile> tileselection = new ArrayList<Tile>();
    private int currentscore = 0;

    private JLabel scoreLabel;


    /**
     * Creates an instance of the Game.
     */
    private Game() {
        // build the GUI as soon as the default constructor is called.
        buildGUI();
    }

    public static Game getGame() {
        if (game == null) {
            game = new Game();
        }
        return game;
    }

    public boolean validMove(Tile tile, Grid grid) {
        if (tileselection.isEmpty()) {
            return true;
        }
        Point lastTilePoint = grid.positionOf(tileselection.getLast());
        Point newTilePoint = grid.positionOf(tile);
        return (Math.abs(newTilePoint.getX() - lastTilePoint.getX()) <= 1.0) && (Math.abs(newTilePoint.getY() - lastTilePoint.getY()) <= 1.0);
    }


    public void setCurrentWord() {
        String submit = "";
        for (Tile t : tileselection) {
            submit = submit.concat(String.valueOf(t.letter()));
        }
        currentword = submit.toLowerCase();

    }

    public void setCurrentScore() {
        int val = 0;
        for (Tile t : tileselection) {
            val += t.value();
        }
        currentscore += val * tileselection.size();
    }

    public boolean checkWord() {
        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
            String line;
            setCurrentWord();
            System.out.println("Current word is " + currentword);
            while ((line = reader.readLine()) != null) {
                if (currentword.equals(line)) {
                    setCurrentScore();
                    System.out.println("Valid word");
                    System.out.println("Total score: " + currentscore);
                    return true;
                }
            }
            System.out.println("Invalid word");
            return false;

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void deactivate(Tile tile, Grid grid, GridGUI gui) {
        tile.active(false);
        gui.setTileBackground(grid.positionOf(tile), Color.darkGray);
        gui.setTileForeground(grid.positionOf(tile), Color.lightGray);

    }

    public void activate(Tile tile, Grid grid, GridGUI gui) {
        tile.active(true);
        gui.setTileForeground(grid.positionOf(tile), Color.yellow);
        gui.setTileBackground(grid.positionOf(tile), Color.blue);

    }

    /**
     * This method will construct each element of the game's GUI
     */
    public void buildGUI() {
        final JFrame frame = new JFrame("Java Word Game");
        TileCollection collection = new TileCollection();
        final Grid grid = new Grid(6, 6, collection);
        final GridGUI gui = new GridGUI(grid);
        gui.setTileForeground(Color.yellow);
        gui.setTileBackground(Color.blue);

        JPanel controls = new JPanel();
        JPanel test = new JPanel();
        JPanel wordEntry = new JPanel();
        JPanel buttons = new JPanel();

        buttons.setLayout(new BorderLayout());
        wordEntry.setLayout(new BorderLayout());
        controls.setLayout(new BorderLayout());

        scoreLabel = new JLabel("Total Score: 0");
        JLabel val = new JLabel("");
        controls.add(scoreLabel);
        test.add(val);

        JButton newGame = new JButton("New Game");
        newGame.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                game = null;
                getGame();
            }
        });


        JButton submit = new JButton("Submit");

        submit.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                if (checkWord()) {
                    for (Tile t : tileselection) {
                        deactivate(t, grid, gui);
                    }
                    val.setText("Valid Word: " + currentword);

                } else {
                    for (Tile t : tileselection) {
                        activate(t, grid, gui);
                    }
                    val.setText("Invalid Word: " + currentword);
                }
                tileselection.clear();
                scoreLabel.setText("Total Score: " + currentscore);
            }
        });


        gui.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent actionEvent) {
                Tile source = (Tile) actionEvent.getSource();
                if (source.checkActive() && validMove(source, grid)) {
                    gui.setTileBackground(grid.positionOf(source), Color.red);
                    gui.setTileForeground(grid.positionOf(source), Color.green);
                    source.active(false);
                    // changes flag on tile to show
                    // used;

                    //add to arraylist of letter pressed
                    tileselection.add(source);
                } else if (tileselection.contains(source)) {
                    int index = tileselection.indexOf(source);
                    for (int i = tileselection.size(); i > index; i--) {
                        Tile last = tileselection.removeLast();
                        activate(last, grid, gui);
                    }
                }

            }
        });

        frame.setTitle("Java Word Game");
        JPanel northPanel = new JPanel();
        northPanel.setLayout(new FlowLayout());
        buttons.setLayout(new FlowLayout());

        frame.getContentPane().setLayout(new BorderLayout());
        frame.getContentPane().add(gui, BorderLayout.WEST);
        frame.getContentPane().add(buttons, BorderLayout.SOUTH);
        frame.getContentPane().add(northPanel, BorderLayout.NORTH);

        northPanel.add(controls);
        northPanel.add(test);

        buttons.add(submit);
        buttons.add(newGame);

        frame.pack();
        frame.setResizable(false);
        frame.toFront();

        frame.setBackground(Color.lightGray);
        frame.setVisible(true);
    }
}
```

