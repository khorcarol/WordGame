### Question 1
**Explain in your own words, with examples, the different between static and non-static methods and
fields.**

Static fields are attributes which are associated with the class itself, whereas non-static fields are attributes associated with instances of a class.

Similarly, static methods are behaviours which belong to the class itself, and non static methods can only be called with an instance of a class.


### Question 2

**Explain why the following code excerpts behave differently when compiled and run:**
```java 
   String s1 = new String("Hi");
   String s2 = new String("Hi");
   System.out.println( (s1==s2) );
   String s3 = "Hi";
   String s4 = "Hi";
   System.out.println( (s3==s4) );
   ```
   

A string literal is a sequence of characters enclosed in double quotation marks such as ``` "Hello World"```
When a string literal is created, Java checks the string pool. If the string literal appears already in the string pool, the new string will reference to the same object in the string pool.
However, using the ```new``` keyword explicitly assigns new chunk of memory in the heap to the object, regardless of whether the content is the same as an existing string in the pool.

The ```.equals``` method in Java checks if two references point to the same object.
Therefore, in case 1, they will not; and in Case 2, they will.

### Question 3

```java 
    public class Car {
        private String manufacturer;
        private int age;

        public int getAge() {
            return age;
        }

        public String getManufacturer() {
            return manufacturer;
        }

        public Car(String manufacturer, int age) {
            this.age = age;
            this.manufacturer = manufacturer;
        }

    }

    class carComparator implements Comparator<Car> {
        @Override
        public int compare(Car c1, Car c2) {
            int a = c1.getManufacturer().compareTo(c2.getManufacturer());
            if (a == 0) {
                if (c1.getAge() > c2.getAge())
                    return 1;
                else if (c1.getAge() == c2.getAge()) {
                    return 0;
                }
                else
                    return -1;
            }
            return a;
        }


        public static void main(String[] args) {

            List<Car> carcollection = new ArrayList<>();
            carcollection.add(new Car("abc", 1));
            carcollection.add(new Car("bc", 1));
            carcollection.add(new Car("abc", 2));
            Collections.sort(carcollection, new carComparator());
            for (Car i : carcollection) {
                System.out.println("Age: "+ i.getAge() + " Manafacturer:" + i.getManufacturer());
            }
        }
    }
    
```
### Question 4

The strategy pattern is where a family of algorithms are defined, but achieves the same result through different ways. It allows the client to choose a type
of algorithm from the family of algorithms during run time.
1. **Context:**
The context is a class which contains a reference to the strategy interface.
The context does not know which strategy is executed, and what it's specific algorithm is.
Includes a setter for the client to set the strategy at runtime.
2. **Strategy Interface:**
An interface which defines abstract methods which are implemented by all concrete strategies.
3. **Concrete Strategy:** Concrete classes which implement the strategy interface.
Each concrete strategy provides a different implementation of the algorithm encapsulated by the strategy interface.
4. **Client:**
Creates a specific concrete strategy object and passes it to the context.

The state pattern is where different types of algorithms are performed based
on the current state of the machine. Different transitions can be followed from each state to 
end up at a different state.
1. **Context:**
The context is a class which stores a reference to its state.
Communicates with state object only via state interface/abstract class.
2. **State interface/abstract class:**
Defines abstract methods that all concrete states have to implement.
3. **Concrete States:**
These classes implement methods from the state interface/abstract class.
Can perform transitions to the next state.

**Comparison:**

State is a subset of Strategy. Both patterns are based on composition, changing behaviour of
the context through delegating work to helper objects.

However, strategies are completely independent and unaware of each other whereas states
can be dependent as you can jump from one state to another.

Strategy pattern is about having different implementations that accomplish the same thing, whereas State pattern 
is about doing different 
things based on the state (reducing the use of if-else statements).

### Question 5
```java
public class Singleton {
    static Singleton s = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() {
        return s;
    }

    public static void main(String[] args) {
        Singleton.getInstance();
    }
}
```

Singleton design pattern is where only one instance of the object can exist and
a global point of access is provided to that instance.

Advantages & Disadvantages

### Question 6
The Decorator Pattern is a structural design pattern which allows one to attach
new behaviours to an object by placing this object inside a special wrapper that 
contains these behaviours.

**Component interface:**
Declares common behaviours for both wrappers and wrapped objects

**Concrete Component:**
Wrapped class which defines basic behaviours, which are altered by decorators.

**Base Decorator:**
Has a field which references the wrapped object via the interface.

**Concrete Decorator:**
Overrides methods of the base decorator.

### Question 7
Inappropriate inheritance. Inheritance should be used in true "is-a" relationships.
Subclasses should be substitutable for the base types without negative side effects by Liskov Substitution Principle.

Anemic Domain Model is where the domain model (representations of real world entities) contain primarily data, with 
little to none business logic. So the data and the operations are separate.

### Question 8

### Question 9
a)
Encapsulation is done through making the PushbackReader
field private, as seen in Line 2. This means no methods outside of class Swapper can access this field.

Abstraction can be done through composition, where methods of the class Swapper contains
instances of PushbackReader to reuse it functionality, hiding the unnecessary details
and only exposing essential features of the object, as seen in Line 3.

Inheritance of code is done through the class Swapper extending Reader, as seen in Line 1. Swapper will inherit methods 
and behaviours of Reader.

Dynamic Polymorphism 
In line 6, class Swapper overrides the read method of the original Reader
class. During runtime, it will be decided if the object is a Swapper or a Reader.
If it is a Swapper (child of Reader), the read method of the Swapper will be used. This is dynamic
polymorphism as the compiler does not know the type of the object during compile time.

b)

Instead of having PushbackReader()

c) Open to extension. To implement different types of reading, make 
a new class which extends the Reader parent class. 
To use it, 

Closed to modification. The Reader class should be closed
and not changed when a new type of reading class is to be implemented.

d) Add another class which extends Reader, but instead of  swap(cbuf, i, i + 1) pn line 9, implement a new 
operation to apply.

e) In order to 
